--------------------------------------------------------------------------------
Profile data file 'callgrind.out' (creator: callgrind-3.22.0)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 902738219
Trigger: Program termination
Profiled target:  ./cub3d maps/test.cub (PID 142483, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                     
--------------------------------------------------------------------------------
4,176,240,540 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                      file:function
--------------------------------------------------------------------------------
2,124,969,214 (50.88%)  src/rendering/render_draw_ray.c:render_draw_ray [/home/val/cub3d/cub3d]
  840,544,535 (20.13%)  src/drawing/draw_basics.c:draw_pixel [/home/val/cub3d/cub3d]
  361,859,059 ( 8.66%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms [/usr/lib/x86_64-linux-gnu/libc.so.6]
  260,807,504 ( 6.25%)  libs/crazypng/src/huffman/huffman_decode.c:huffman_decode [/home/val/cub3d/cub3d]
  192,822,970 ( 4.62%)  src/rendering/raycast_dda.c:render_ray [/home/val/cub3d/cub3d]
   69,782,278 ( 1.67%)  libs/crazypng/src/utils/buffer_utils.c:cp_buffer_add.constprop.0 [/home/val/cub3d/cub3d]
   48,713,135 ( 1.17%)  libs/crazypng/src/png/png_unfilter_algos.c:png_open
   46,534,408 ( 1.11%)  libs/crazypng/src/bitstream/bitstream_misc.c:huffman_decode
   37,327,884 ( 0.89%)  libs/crazypng/src/deflate/inflate_decode.c:inflate_block_huffman
   36,505,734 ( 0.87%)  libs/crazypng/src/png/png_pixel_unpacking.c:png_open
   31,398,861 ( 0.75%)  src/tilemaps/tilemap_basics.c:tilemap_is_tile_valid [/home/val/cub3d/cub3d]
   25,651,752 ( 0.61%)  src/minimap/minimap_drawing.c:draw_tile [/home/val/cub3d/cub3d]
   15,859,320 ( 0.38%)  libs/crazypng/src/deflate/lz77.c:inflate_block_huffman
   15,513,267 ( 0.37%)  ???:fmin [/home/val/cub3d/cub3d]
    9,158,850 ( 0.22%)  src/tilemaps/tilemap_basics.c:tilemap_get_tile [/home/val/cub3d/cub3d]
    8,325,842 ( 0.20%)  ???:clamp [/home/val/cub3d/cub3d]
    7,735,392 ( 0.19%)  libs/crazypng/libft/memory/ft_memcpy.c:cp_buffer_add.constprop.0
    6,305,506 ( 0.15%)  libs/crazypng/src/bitstream/bitstream_utils.c:inflate_block_huffman

--------------------------------------------------------------------------------
-- Auto-annotated source: src/tilemaps/tilemap_basics.c
--------------------------------------------------------------------------------
Ir                  

-- line 9 ----------------------------------------
         .           /*   Updated: 2025/06/16 16:35:27 by vdurand          ###   ########.fr       */
         .           /*                                                                            */
         .           /* ************************************************************************** */
         .           
         .           #include "cub3d.h"
         .           #include "tilemap.h"
         .           
         .           bool	tilemap_is_tile_valid(size_t x, size_t y, t_tilemap *map)
 5,130,769 ( 0.12%)  {
21,138,862 ( 0.51%)  	return (x < map->width && y < map->height);
 5,130,769 ( 0.12%)  }
         .           
         .           t_tile	*tilemap_get_tile(size_t x, size_t y, t_tilemap *map)
 1,526,475 ( 0.04%)  {
 6,107,268 ( 0.15%)  	return (&map->tiles[y][x]);
 1,526,475 ( 0.04%)  }
         .           
         .           bool	tilemap_collision(float x, float y, float z, t_tilemap *tilemap)
         .           {
         .           	t_tile	*tile;
         .           
       756 ( 0.00%)  	if (!tilemap_is_tile_valid(x, y, tilemap))
         .           		return (true);
         .           	tile = tilemap_get_tile((size_t) x, (size_t)  y, tilemap);
     2,286 ( 0.00%)  	return (!tile->info.solid || (tile->ceiling < z || tile->floor > z));
         .           }
         .           
         .           bool tilemap_collision_bbox(t_vec3 axis, t_bbox bbox, t_tilemap *map)
       378 ( 0.00%)  {
         .           	bool	collide;
         .           	float	z_top;
         .           	float	z_bot;
         .           
       189 ( 0.00%)  	z_bot = bbox.min.z + axis.z;
       126 ( 0.00%)  	z_top = bbox.max.z + axis.z;
         .           	collide = \
       126 ( 0.00%)  	tilemap_collision(bbox.min.x + axis.x, bbox.min.y + axis.y, z_bot, map)
        63 ( 0.00%)  	&& tilemap_collision(bbox.max.x + axis.x, bbox.min.y + axis.y, z_bot, map)
        63 ( 0.00%)  	&& tilemap_collision(bbox.min.x + axis.x, bbox.max.y + axis.y, z_bot, map)
         .           	&& tilemap_collision(bbox.max.x + axis.x, bbox.max.y + axis.y, z_bot, map)
         .           	&& tilemap_collision(bbox.min.x + axis.x, bbox.min.y + axis.y, z_top, map)
         .           	&& tilemap_collision(bbox.max.x + axis.x, bbox.min.y + axis.y, z_top, map)
         .           	&& tilemap_collision(bbox.min.x + axis.x, bbox.max.y + axis.y, z_top, map)
         .           	&& tilemap_collision(bbox.max.x + axis.x, bbox.max.y + axis.y, z_top, map);
         .           
         .           	return (!collide);
       189 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: libs/crazypng/src/deflate/inflate_decode.c
--------------------------------------------------------------------------------
Ir                  

-- line 39 ----------------------------------------
         .           
         .           bool	inflate_copy_reference(t_inflate_context *context,
         .           			int distance, int length)
         .           {
         .           	uint8_t	byte;
         .           	size_t	temp_pos;
         .           	int		index;
         .           
    36,410 ( 0.00%)  	temp_pos = (context->reference_window.pos
    72,820 ( 0.00%)  			- distance + LZ77_WINDOW_SIZE) % LZ77_WINDOW_SIZE;
   145,640 ( 0.00%)  	index = 0;
 6,257,724 ( 0.15%)  	while (index < length)
         .           	{
 6,148,494 ( 0.15%)  		byte = context->reference_window.buffer[temp_pos];
15,444,055 ( 0.37%)  		if (!cp_buffer_add(context->output, &byte, 1))
75,202,572 ( 1.80%)  => /home/val/cub3d/libs/crazypng/src/utils/buffer_utils.c:cp_buffer_add.constprop.0 (3,074,247x)
         .           			return (false);
         .           		lz77_window_push(&context->reference_window, byte);
 6,148,494 ( 0.15%)  		temp_pos = (temp_pos + 1) % LZ77_WINDOW_SIZE;
 3,074,247 ( 0.07%)  		index++;
         .           	}
         .           	return (true);
         .           }

--------------------------------------------------------------------------------
-- Auto-annotated source: libs/crazypng/src/png/png_unfilter_algos.c
--------------------------------------------------------------------------------
Ir                 

-- line 12 ----------------------------------------
        .           
        .           #include "crazypng_png.h"
        .           
        .           void	png_filter_sub(t_png_unfilter_context *context, uint8_t *raw_line)
        .           {
        .           	size_t	i;
        .           	uint8_t	left;
        .           
      120 ( 0.00%)  	i = 0;
  164,160 ( 0.00%)  	while (i < context->lines_bytes)
        .           	{
        .           		if (i < context->bpp)
        .           			left = 0;
        .           		else
   81,350 ( 0.00%)  			left = context->current_line[i - context->bpp];
  244,070 ( 0.01%)  		context->current_line[i] = raw_line[i] + left;
   81,420 ( 0.00%)  		i++;
        .           	}
        .           }
        .           
        .           void	png_filter_up(t_png_unfilter_context *context,
        .           	uint8_t *raw_line)
        .           {
        .           	size_t	i;
        .           
        .           	i = 0;
   33,604 ( 0.00%)  	while (i < context->lines_bytes)
        .           	{
  897,104 ( 0.02%)  		context->current_line[i] = raw_line[i] + context->prev_line[i];
    7,416 ( 0.00%)  		i++;
        .           	}
        .           }
        .           
        .           void	png_filter_average(t_png_unfilter_context *context, uint8_t *raw_line)
        .           {
        .           	size_t	i;
        .           	uint8_t	left;
        .           	uint8_t	up;
-- line 49 ----------------------------------------
-- line 63 ----------------------------------------
        .           
        .           static uint8_t	paeth_predictor(int a, int b, int c)
        .           {
        .           	int	p;
        .           	int	pa;
        .           	int	pb;
        .           	int	pc;
        .           
2,192,848 ( 0.05%)  	p = a + b - c;
        .           	pa = p - a;
        .           	if (pa < 0)
6,578,544 ( 0.16%)  		pa = -pa;
        .           	pb = p - b;
        .           	if (pb < 0)
6,578,544 ( 0.16%)  		pb = -pb;
        .           	pc = p - c;
        .           	if (pc < 0)
4,385,696 ( 0.11%)  		pc = -pc;
5,486,904 ( 0.13%)  	if (pa <= pb && pa <= pc)
1,909,590 ( 0.05%)  		return ((uint8_t)a);
        .           	if (pb <= pc)
  283,258 ( 0.01%)  		return ((uint8_t)b);
        .           	return ((uint8_t)c);
        .           }
        .           
        .           void	png_filter_paeth(t_png_unfilter_context *context, uint8_t *raw_line)
        .           {
        .           	size_t	i;
        .           	uint8_t	left;
        .           	uint8_t	up_left;
        .           	uint8_t	up;
        .           
        .           	i = 0;
4,419,808 ( 0.11%)  	while (i < context->lines_bytes)
        .           	{
        .           		if (i < context->bpp)
        .           		{
        .           			left = 0;
        .           			up_left = 0;
        .           		}
        .           		else
        .           		{
3,291,594 ( 0.08%)  			left = context->current_line[i - context->bpp];
3,294,690 ( 0.08%)  			up_left = context->prev_line[i - context->bpp];
        .           		}
2,195,240 ( 0.05%)  		up = context->prev_line[i];
2,195,240 ( 0.05%)  		context->current_line[i] = raw_line[i]
2,196,695 ( 0.05%)  			+ paeth_predictor(left, up, up_left);
2,195,240 ( 0.05%)  		i++;
        .           	}
        .           }

--------------------------------------------------------------------------------
-- Auto-annotated source: libs/crazypng/libft/memory/ft_memcpy.c
--------------------------------------------------------------------------------
Ir                 

-- line 13 ----------------------------------------
        .           #include "libft.h"
        .           
        .           void	*ft_memcpy(void *dest, const void *src, size_t n)
        .           {
        .           	unsigned char	*o_dest;
        .           	unsigned char	*o_src;
        .           	size_t			index;
        .           
      816 ( 0.00%)  	index = 0;
        .           	o_dest = (unsigned char *) dest;
        .           	o_src = (unsigned char *) src;
    2,121 ( 0.00%)  	while (index < n)
        .           	{
7,924,827 ( 0.19%)  		o_dest[index] = o_src[index];
      350 ( 0.00%)  => ???:0x000000000010a970 (2x)
      536 ( 0.00%)  		index++;
        .           	}
        .           	return (dest);
        .           }
        .           
        .           /* int	main(void)
        .           {
        .           	char test[50];
        .           	char *test2 = "TEST";
-- line 35 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libs/crazypng/src/huffman/huffman_decode.c
--------------------------------------------------------------------------------
Ir                  

-- line 9 ----------------------------------------
         .           /*   Updated: 2025/05/05 16:54:22 by val              ###   ########.fr       */
         .           /*                                                                            */
         .           /* ************************************************************************** */
         .           
         .           #include "crazypng_huffman.h"
         .           #include "crazypng_bitstream.h"
         .           
         .           int	huffman_decode(t_bitstream *stream, t_huffman_table *tab)
   519,171 ( 0.01%)  {
         .           	uint32_t	buf;
         .           	uint8_t		len;
         .           	uint32_t	code;
         .           	size_t		i;
         .           
         .           	i = 0;
         .           	buf = bs_peek_bits(stream, tab->max_bits);
61,694,112 ( 1.48%)  	while (i < tab->count)
         .           	{
62,040,226 ( 1.49%)  		if (tab->codes[i].bits == 0)
         .           		{
         .           			i++;
         .           			continue ;
         .           		}
         .           		len = tab->codes[i].bits;
86,621,797 ( 2.07%)  		code = buf & ((1 << len) - 1);
49,413,027 ( 1.18%)  		if (code == tab->codes[i].code)
         .           		{
         .           			if (!bs_consume_bits(stream, len))
         .           				return (-2);
   173,057 ( 0.00%)  			return (i);
         .           		}
         .           		i++;
         .           	}
         .           	return (-1);
   346,114 ( 0.01%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: src/rendering/render_draw_ray.c
--------------------------------------------------------------------------------
Ir                   

-- line 38 ----------------------------------------
          .           static inline void	draw_wall(t_raycast_hit *hit, int wall_start,
          .           			int wall_end, t_raycast_context *ctx)
          .           {
          .           	int				y;
          .           	t_rgba8			color;
          .           	int				buffer_idx;
          .           
          .           	color = (t_rgba8){255, 255, 0, 0};
  1,135,558 ( 0.03%)  	y = wall_start;
 92,528,115 ( 2.22%)  	while (y < wall_end)
          .           	{
542,090,136 (12.98%)  		buffer_idx = y * WINDOW_WIDTH + ctx->column;
917,595,298 (21.97%)  		if (hit->dist < ctx->render_ctx->z_buffer[buffer_idx])
          .           		{
143,794,532 ( 3.44%)  			draw_pixel(color, ctx->column, y, ctx->render_ctx->frame);
790,869,926 (18.94%)  => /home/val/cub3d/src/drawing/draw_basics.c:draw_pixel (35,948,633x)
206,689,059 ( 4.95%)  			ctx->render_ctx->z_buffer[buffer_idx] = hit->dist;
          .           		}
180,696,712 ( 4.33%)  		y++;
          .           	}
          .           }
          .           
          .           static inline void draw_ceiling(t_raycast_hit *hit, int y,
          .           		t_raycast_context *ctx, t_render_context *r_ctx)
          .           {
          .           	float	real_dist;
          .           	t_rgba8	color;
-- line 63 ----------------------------------------
-- line 83 ----------------------------------------
          .           		}
          .           		y -= 1;
          .           	}
          .           }
          .           
          .           void	render_draw_ray(t_raycast_hit *hit,
          .           			t_raycast_context *ctx,
          .           			t_render_context *render)
  6,541,733 ( 0.16%)  {
          .           	float	corrected_dist;
          .           	int		wall_start;
          .           	int		wall_end;
          .           	float	y_floor;
          .           	float	y_ceiling;
          .           
  1,784,109 ( 0.04%)  	corrected_dist = hit->dist
  3,568,218 ( 0.09%)  		* cosf(hit->original_angle - render->direction);
 13,676,097 ( 0.33%)  => ???:0x000000000010a810 (594,703x)
          .           	/*init_texture_ctx(&tex_ctx, corrected_dist, ctx->column);
          .           	set_texture_orientation(hit);*/
  2,378,812 ( 0.06%)  	y_floor = ((hit->tile->floor - render->eye_height)
  1,784,109 ( 0.04%)  		/ corrected_dist) * render->proj_dist_y;
  1,189,406 ( 0.03%)  	y_ceiling = ((hit->tile->ceiling - render->eye_height)
    594,703 ( 0.01%)  		/ corrected_dist) * render->proj_dist_y;
    594,703 ( 0.01%)  	hit->pos.x = hit->original_ray.origin.x \
  2,973,515 ( 0.07%)  		+ hit->original_ray.dir_normal.x * hit->dist;
          .           	hit->pos.y = hit->original_ray.origin.y \
          .           		+ hit->original_ray.dir_normal.y * hit->dist;
  5,352,327 ( 0.13%)  	wall_start = clamp(-y_ceiling + render->halfh, 0, WINDOW_HEIGHT - 1);
  4,162,921 ( 0.10%)  => ???:clamp (594,703x)
  5,947,030 ( 0.14%)  	wall_end = clamp(-y_floor + render->halfh, 0, WINDOW_HEIGHT - 1);
  4,162,921 ( 0.10%)  => ???:clamp (594,703x)
          .           	draw_wall(hit, wall_start, wall_end, ctx);
  2,973,515 ( 0.07%)  	if (hit->tile->ceiling < render->eye_height)
          .           		draw_ceiling(hit, wall_start, ctx, render);
  4,757,624 ( 0.11%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: src/rendering/raycast_dda.c
--------------------------------------------------------------------------------
Ir                  

-- line 17 ----------------------------------------
         .           static inline void	raycast_launch(t_raycast_context *ctx);
         .           static inline bool	check_wall_tile(t_raycast_hit *hit,
         .           		t_raycast_context *ctx);
         .           static inline void	raycast_set_dist(t_raycast_hit *hit,
         .           		t_raycast_context *ctx);
         .           
         .           void	render_ray(float base_angle, int column,
         .           		t_ray2 *ray, t_render_context *render_ctx)
   403,200 ( 0.01%)  {
         .           	t_raycast_context	ctx;
         .           
    40,320 ( 0.00%)  	ctx.actual.original_angle = base_angle;
    80,640 ( 0.00%)  	ctx.actual.original_ray = *ray;
    40,320 ( 0.00%)  	ctx.column = column;
   120,960 ( 0.00%)  	ctx.render_ctx = render_ctx;
         .           	ctx.ray = ray;
    80,640 ( 0.00%)  	ctx.tilemap = render_ctx->tilemap;
   161,280 ( 0.00%)  	ctx.step.x = sign(ray->dir_normal.x);
   403,200 ( 0.01%)  => ???:sign (40,320x)
   161,280 ( 0.00%)  	ctx.step.y = sign(ray->dir_normal.y);
   403,200 ( 0.01%)  => ???:sign (40,320x)
    80,640 ( 0.00%)  	ctx.actual.orientation = 0;
         .           	raycast_init(&ctx);
         .           	raycast_launch(&ctx);
   362,880 ( 0.01%)  }
         .           
         .           static inline void	raycast_init(t_raycast_context *ctx)
         .           {
         .           	t_ray2	*ray;
         .           
    40,320 ( 0.00%)  	ray = ctx->ray;
   120,960 ( 0.00%)  	ctx->actual_tile.x = (int)(ray->origin.x);
         .           	ctx->actual_tile.y = (int)(ray->origin.y);
   201,600 ( 0.00%)  	if (float_equal(ray->dir_normal.x, 0))
   322,560 ( 0.01%)  => ???:float_equal (40,320x)
    40,320 ( 0.00%)  		ctx->delta_dist.x = INFINITY;
         .           	else
   120,960 ( 0.00%)  		ctx->delta_dist.x = fabs(1 / ray->dir_normal.x);
   241,920 ( 0.01%)  	if (float_equal(ray->dir_normal.y, 0))
   322,560 ( 0.01%)  => ???:float_equal (40,320x)
    40,320 ( 0.00%)  		ctx->delta_dist.y = INFINITY;
         .           	else
   120,960 ( 0.00%)  		ctx->delta_dist.y = fabs(1 / ray->dir_normal.y);
   120,960 ( 0.00%)  	if (ray->dir_normal.x < 0.0)
         .           		ctx->step_dist.x = 
   120,960 ( 0.00%)  			(ray->origin.x - ctx->actual_tile.x) * ctx->delta_dist.x;
         .           	else
         .           		ctx->step_dist.x = 
   322,560 ( 0.01%)  			(ctx->actual_tile.x + 1.0 - ray->origin.x) *  ctx->delta_dist.x;
   120,960 ( 0.00%)  	if (ray->dir_normal.y < 0.0)
         .           		ctx->step_dist.y = 
   212,418 ( 0.01%)  			(ray->origin.y - ctx->actual_tile.y) * ctx->delta_dist.y;
         .           	else
         .           		ctx->step_dist.y = 
   227,496 ( 0.01%)  			(ctx->actual_tile.y + 1.0 - ray->origin.y) *  ctx->delta_dist.y;
         .           }
         .           
         .           static inline void	raycast_launch(t_raycast_context *ctx)
         .           {
61,972,428 ( 1.48%)  	while (fmin(ctx->step_dist.x, ctx->step_dist.y) < RENDER_DISTANCE)
15,513,267 ( 0.37%)  => ???:fmin (5,171,089x)
         .           	{
10,261,538 ( 0.25%)  		if (ctx->step_dist.x < ctx->step_dist.y)
         .           		{
 7,293,422 ( 0.17%)  			ctx->step_dist.x += ctx->delta_dist.x;
19,717,613 ( 0.47%)  			ctx->actual_tile.x += ctx->step.x;
         .           			ctx->actual.orientation = 0;
         .           		}
         .           		else
         .           		{
 2,968,116 ( 0.07%)  			ctx->step_dist.y += ctx->delta_dist.y;
11,067,001 ( 0.26%)  			ctx->actual_tile.y += ctx->step.y;
 1,484,058 ( 0.04%)  			ctx->actual.orientation = 1;
         .           		}
         .           		if (check_wall_tile(&ctx->actual, ctx))
         .           		{
         .           			raycast_set_dist(&ctx->actual, ctx);
 3,568,218 ( 0.09%)  			render_draw_ray(&ctx->actual, ctx, ctx->render_ctx);
2,937,841,079 (70.35%)  => /home/val/cub3d/src/rendering/render_draw_ray.c:render_draw_ray (594,703x)
         .           		}
         .           	}
         .           }
         .           
         .           static inline bool	check_wall_tile(t_raycast_hit *hit,
         .           		t_raycast_context *ctx)
         .           {
         .           	t_tile	*tile;
         .           	int		tile_x;
         .           	int		tile_y;
         .           
         .           	tile_x = ctx->actual_tile.x;
         .           	tile_y = ctx->actual_tile.y;
42,572,627 ( 1.02%)  	if (!tilemap_is_tile_valid(tile_x, tile_y, ctx->tilemap))
31,398,861 ( 0.75%)  => /home/val/cub3d/src/tilemaps/tilemap_basics.c:tilemap_is_tile_valid (5,130,769x)
         .           		return (false);
 9,158,850 ( 0.22%)  	tile = tilemap_get_tile(tile_x, tile_y, ctx->tilemap);
 9,158,850 ( 0.22%)  => /home/val/cub3d/src/tilemaps/tilemap_basics.c:tilemap_get_tile (1,526,475x)
 1,526,475 ( 0.04%)  	hit->tile_x = tile_x;
         .           	hit->tile_y = tile_y;
 6,105,900 ( 0.15%)  	hit->tile_info = &tile->info;
         .           	hit->tile = tile;
 3,052,950 ( 0.07%)  	if (hit->tile_info->wall)
         .           		return (true);
         .           	return (false);
         .           }
         .           
         .           static inline void	raycast_set_dist(t_raycast_hit *hit,
         .           		t_raycast_context *ctx)
         .           {
 1,189,406 ( 0.03%)  	if (hit->orientation == 0)
 2,321,283 ( 0.06%)  		hit->dist = (ctx->actual_tile.x - ctx->ray->origin.x
 3,184,573 ( 0.08%)  			+ (1 - ctx->step.x) * 0.5) / ctx->ray->dir_normal.x;
         .           	else
   652,232 ( 0.02%)  		hit->dist = (ctx->actual_tile.y - ctx->ray->origin.y
 1,141,406 ( 0.03%)  			+ (1 - ctx->step.y) * 0.5) / ctx->ray->dir_normal.y;
         .           	
         .           }

--------------------------------------------------------------------------------
-- Auto-annotated source: libs/crazypng/src/utils/buffer_utils.c
--------------------------------------------------------------------------------
Ir                  

-- line 16 ----------------------------------------
         .            * @brief Ajoute des données à un buffer dynamique
         .            * 
         .            * @param buf Buffer à modifier
         .            * @param to_add Données à ajouter
         .            * @param len Longueur des données en octets
         .            * @return true Succès
         .            * @return false Échec d'allocation mémoire
         .            */
22,203,048 ( 0.53%)  bool	cp_buffer_add(t_cp_buffer *buf, void *to_add, size_t len)
       210 ( 0.00%)  {
         .           	size_t	new_capacity;
         .           	uint8_t	*new_data;
         .           
 3,171,885 ( 0.08%)  	new_capacity = buf->capacity;
12,687,540 ( 0.30%)  	if (buf->size + len > buf->capacity)
         .           	{
       210 ( 0.00%)  		if (new_capacity < 1024)
         .           			new_capacity = 1024;
       406 ( 0.00%)  		while (new_capacity < buf->capacity + len)
        74 ( 0.00%)  			new_capacity *= 2;
       210 ( 0.00%)  		new_data = malloc(new_capacity);
    19,373 ( 0.00%)  => ???:0x000000000010a630 (53x)
       140 ( 0.00%)  		if (!new_data)
         .           			return (false);
       210 ( 0.00%)  		if (buf->data)
         .           		{
         .           			ft_memcpy(new_data, buf->data, buf->size);
        60 ( 0.00%)  			free(buf->data);
     9,044 ( 0.00%)  => ???:0x000000000010a6a0 (48x)
         .           		}
        70 ( 0.00%)  		buf->data = new_data;
        70 ( 0.00%)  		buf->capacity = new_capacity;
         .           	}
 6,343,930 ( 0.15%)  	ft_memcpy(buf->data + buf->size, to_add, len);
 3,171,927 ( 0.08%)  	buf->size += len;
 3,171,885 ( 0.08%)  	return (true);
19,031,415 ( 0.46%)  }
         .           
         .           void	cp_buffer_free(t_cp_buffer *buffer)
         .           {
         .           	cp_buffer_reset(buffer);
         .           	free(buffer);
         .           }
         .           
         .           /**
         .            * @brief Réinitialise un buffer (libère la mémoire et remet à zéro)
         .            * 
         .            * @param buffer Buffer à réinitialiser
         .            */
         .           void	cp_buffer_reset(t_cp_buffer *buffer)
         .           {
        60 ( 0.00%)  	if (buffer->data)
         .           	{
        10 ( 0.00%)  		free(buffer->data);
     2,586 ( 0.00%)  => ???:0x000000000010a6a0 (10x)
        20 ( 0.00%)  		buffer->data = NULL;
         .           	}
        45 ( 0.00%)  	buffer->size = 0;
         .           	buffer->capacity = 0;
         .           }

--------------------------------------------------------------------------------
-- Auto-annotated source: libs/crazypng/src/bitstream/bitstream_utils.c
--------------------------------------------------------------------------------
Ir                 

-- line 21 ----------------------------------------
        .            * 
        .            * @warning Ne vérifie pas les dépassements de buffer
        .            */
        .           uint64_t	bs_read_bits(t_bitstream *bs, int count)
        .           {
        .           	uint64_t	result;
        .           	int			i;
        .           
  384,380 ( 0.01%)  	if (count <= 0 || count > 64 || bs->overflowed)
        .           		return (0);
   92,424 ( 0.00%)  	result = 0;
        .           	i = 0;
  627,549 ( 0.02%)  	while (i < count)
        .           	{
  718,980 ( 0.02%)  		if (bs->byte_pos >= bs->size)
        .           		{
        .           			bs->overflowed = true;
        .           			return (0);
        .           		}
2,820,351 ( 0.07%)  		result |= (uint32_t)((bs->data[bs->byte_pos] >> bs->bit_pos) & 1) << i;
  588,340 ( 0.01%)  		bs->bit_pos++;
  627,386 ( 0.02%)  		if (bs->bit_pos == 8)
        .           		{
   39,166 ( 0.00%)  			bs->bit_pos = 0;
  110,961 ( 0.00%)  			bs->byte_pos++;
        .           		}
  312,466 ( 0.01%)  		i++;
        .           	}
        .           	return (result);
        .           }
        .           
        .           bool	bs_align(t_bitstream *bs)
        .           {
        .           	if (bs->bit_pos != 0)
        .           	{
-- line 55 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libs/crazypng/src/deflate/lz77.c
--------------------------------------------------------------------------------
Ir                 

-- line 9 ----------------------------------------
        .           /*   Updated: 2025/06/23 00:28:38 by vdurand          ###   ########.fr       */
        .           /*                                                                            */
        .           /* ************************************************************************** */
        .           
        .           #include "crazypng_deflate.h"
        .           
        .           bool	lz77_window_push(t_lz77_window *win, uint8_t byte)
        .           {
6,343,728 ( 0.15%)  	win->buffer[win->pos] = byte;
9,515,592 ( 0.23%)  	win->pos = (win->pos + 1) % LZ77_WINDOW_SIZE;
        .           	return (true);
        .           }
        .           
        .           bool	lz77_window_push_bytes(t_lz77_window *win,
        .           			const uint8_t *src, size_t len)
        .           {
        .           	size_t	index;
        .           
-- line 26 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: libs/crazypng/src/bitstream/bitstream_misc.c
--------------------------------------------------------------------------------
Ir                  

-- line 14 ----------------------------------------
         .           
         .           uint64_t	bs_peek_bits(t_bitstream *bs, int count)
         .           {
         .           	uint64_t	n;
         .           	int			i;
         .           	size_t		temp_byte_pos;
         .           	int			temp_bit_pos;
         .           
 1,211,399 ( 0.03%)  	if (count <= 0 || count > 64 || bs->overflowed)
         .           		return (0);
   173,057 ( 0.00%)  	n = 0;
   173,057 ( 0.00%)  	i = 0;
   346,114 ( 0.01%)  	temp_byte_pos = bs->byte_pos;
   173,057 ( 0.00%)  	temp_bit_pos = bs->bit_pos;
 5,149,982 ( 0.12%)  	while (i < count)
         .           	{
 5,496,096 ( 0.13%)  		if (temp_byte_pos >= bs->size)
         .           			return (0);
20,599,928 ( 0.49%)  		n |= (uint64_t)((bs->data[temp_byte_pos] >> temp_bit_pos) & 1) << i;
 2,574,991 ( 0.06%)  		temp_bit_pos++;
 5,149,982 ( 0.12%)  		if (temp_bit_pos == 8)
         .           		{
   321,902 ( 0.01%)  			temp_bit_pos = 0;
   321,902 ( 0.01%)  			temp_byte_pos++;
         .           		}
 2,574,991 ( 0.06%)  		i++;
         .           	}
         .           	return (n);
         .           }
         .           
         .           bool	bs_consume_bits(t_bitstream *stream, size_t n)
         .           {
   519,171 ( 0.01%)  	if (!stream || stream->overflowed)
         .           		return (false);
   346,114 ( 0.01%)  	stream->bit_pos += n;
 1,056,551 ( 0.03%)  	while (stream->bit_pos >= 8)
         .           	{
         .           		stream->byte_pos++;
         .           		stream->bit_pos -= 8;
         .           	}
   346,114 ( 0.01%)  	if (stream->byte_pos >= stream->size)
         .           	{
         .           		stream->overflowed = true;
         .           		return (false);
         .           	}
         .           	return (true);
         .           }

--------------------------------------------------------------------------------
-- Auto-annotated source: src/drawing/draw_basics.c
--------------------------------------------------------------------------------
Ir                   

-- line 8 ----------------------------------------
          .           /*   Created: 2025/06/05 22:58:41 by vdurand           #+#    #+#             */
          .           /*   Updated: 2025/06/23 01:12:50 by vdurand          ###   ########.fr       */
          .           /*                                                                            */
          .           /* ************************************************************************** */
          .           
          .           #include "cub3d.h"
          .           
          .           void draw_pixel(t_rgba8 src, unsigned int x, unsigned int y, t_img_data *img) 
150,507,317 ( 3.60%)  {
          .           	uint32_t	*pixel;
          .           	uint8_t		*bytes;
          .           	uint32_t	src_alpha;
          .           	uint32_t	inv_alpha;
          .           
261,038,330 ( 6.25%)  	pixel = (uint32_t *)(img->buffer + (y * img->size_line) + (x << 2));
 74,582,380 ( 1.79%)  	if (src.a == 255)
323,537,697 ( 7.75%)  		*pixel = (src.a << 24) | (src.r << 16) | (src.g << 8) | src.b;
          .           	else
          .           	{
          .           		bytes = (uint8_t *)pixel;
  1,342,557 ( 0.03%)  		src_alpha = src.a;
  2,685,114 ( 0.06%)  		inv_alpha = 255 - src_alpha;
  6,712,785 ( 0.16%)  		bytes[0] = (src.b * src_alpha + bytes[0] * inv_alpha + 128) >> 8;
  8,055,342 ( 0.19%)  		bytes[1] = (src.g * src_alpha + bytes[1] * inv_alpha + 128) >> 8;
  8,055,342 ( 0.19%)  		bytes[2] = (src.r * src_alpha + bytes[2] * inv_alpha + 128) >> 8;
  1,342,557 ( 0.03%)  		bytes[3] = 255;
          .           	}
  2,685,114 ( 0.06%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: src/minimap/minimap_drawing.c
--------------------------------------------------------------------------------
Ir                 

-- line 8 ----------------------------------------
        .           /*   Created: 2025/06/11 10:49:50 by halnuma           #+#    #+#             */
        .           /*   Updated: 2025/06/20 15:55:26 by vdurand          ###   ########.fr       */
        .           /*                                                                            */
        .           /* ************************************************************************** */
        .           
        .           #include "cub3d.h"
        .           
        .           void	draw_tile(t_tile_context *tile, t_png_pixel8 color)
   48,384 ( 0.00%)  {
        .           	int	i;
        .           	int	j;
        .           	int	x;
        .           	int	y;
        .           
    5,376 ( 0.00%)  	i = 0;
  172,032 ( 0.00%)  	while (i < MMAP_TILE_SIZE)
        .           	{
        .           		j = 0;
  573,216 ( 0.01%)  		while (j < MMAP_TILE_SIZE)
        .           		{
6,506,136 ( 0.16%)  			x = (tile->pos_x * MMAP_TILE_SIZE + i - tile->off_x \
        .           				+ MINIMAP_X_START + MINIMAP_BORDER);
5,425,080 ( 0.13%)  			y = (tile->pos_y * MMAP_TILE_SIZE + j - tile->off_y \
        .           				+ MINIMAP_Y_START + MINIMAP_BORDER);
2,628,672 ( 0.06%)  			if (x >= MINIMAP_X_START + MINIMAP_BORDER && \
        .           				x < MINIMAP_X_START + MINIMAP_SIZE && \
2,620,416 ( 0.06%)  				y >= MINIMAP_Y_START + MINIMAP_BORDER && \
        .           				y < MINIMAP_Y_START + MINIMAP_SIZE)
6,243,960 ( 0.15%)  				draw_pixel(color, x, y, tile->game->img);
46,205,304 ( 1.11%)  => /home/val/cub3d/src/drawing/draw_basics.c:draw_pixel (1,248,792x)
1,310,208 ( 0.03%)  			j++;
        .           		}
   86,016 ( 0.00%)  		i++;
        .           	}
   32,256 ( 0.00%)  }
        .           
        .           void	draw_border(t_game *game)
   10,395 ( 0.00%)  {
        .           	int				i;
        .           	int				j;
        .           	t_png_pixel8	color;
        .           
        .           	color = rgba8(25, 255, 25, 200);
        .           	i = 0;
   10,647 ( 0.00%)  	while (i < MINIMAP_SIZE)
        .           	{
        .           		j = 0;
1,502,550 ( 0.04%)  		while (j < MINIMAP_SIZE)
        .           		{
2,509,920 ( 0.06%)  			if (j < MINIMAP_BORDER || \
        .           				j > MINIMAP_SIZE - MINIMAP_BORDER || \
        .           				i < MINIMAP_BORDER || \
        .           				i > MINIMAP_SIZE - MINIMAP_BORDER)
        .           			{
  462,105 ( 0.01%)  				draw_pixel(color, i + MINIMAP_X_START,
3,419,577 ( 0.08%)  => /home/val/cub3d/src/drawing/draw_basics.c:draw_pixel (92,421x)
        .           					j + MINIMAP_Y_START, game->img);
        .           			}
        .           			j++;
        .           		}
        .           		i++;
        .           	}
       84 ( 0.00%)  }
        .           
        .           void	draw_player(t_game *game)
      462 ( 0.00%)  {
        .           	int	i;
        .           	int	j;
        .           
        .           	i = 0;
      504 ( 0.00%)  	while (i < MINIMAP_P_SIZE)
        .           	{
        .           		j = 0;
    4,032 ( 0.00%)  		while (j < MINIMAP_P_SIZE)
        .           		{
    6,720 ( 0.00%)  			draw_pixel(
   49,728 ( 0.00%)  => /home/val/cub3d/src/drawing/draw_basics.c:draw_pixel (1,344x)
        .           				rgba8(255, 0, 10, 200),
        .           				((7 * MMAP_TILE_SIZE) + i + MINIMAP_X_START \
        .           				+ MINIMAP_BORDER - (MINIMAP_P_SIZE / 2)),
        .           				((7 * MMAP_TILE_SIZE) + j + MINIMAP_Y_START \
        .           				+ MINIMAP_BORDER - (MINIMAP_P_SIZE / 2)),
        .           				game->img
        .           				);
        .           			j++;
        .           		}
        .           		i++;
        .           	}
       84 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: libs/crazypng/src/png/png_pixel_unpacking.c
--------------------------------------------------------------------------------
Ir                 

-- line 20 ----------------------------------------
        .           bool	unpack_scanline_to_pixels(t_png_unfilter_context *context,
        .           			t_png *png)
        .           {
        .           	size_t			x;
        .           	size_t			channel;
        .           	size_t			bit_pos;
        .           	t_png_pixel8	*out;
        .           
    6,840 ( 0.00%)  	out = png->pixels_8bit + png->header.width * context->y;
   13,680 ( 0.00%)  	x = 0;
4,166,160 ( 0.10%)  	while (x < png->header.width)
        .           	{
       30 ( 0.00%)  		bit_pos = x * context->channels_number * context->bit_depths;
        .           		channel = 0;
6,242,400 ( 0.15%)  		while (channel < context->channels_number)
        .           		{
        .           			unpack_pixel(context, out, bit_pos, channel);
2,080,800 ( 0.05%)  			bit_pos += context->bit_depths;
        .           			channel++;
        .           		}
        .           		if (!unpack_clean(context, out))
        .           			return (false);
1,040,400 ( 0.02%)  		out++;
1,040,400 ( 0.02%)  		x++;
        .           	}
        .           	return (true);
        .           }
        .           
        .           static void	unpack_pixel(t_png_unfilter_context *context, t_png_pixel8 *out,
        .           				size_t bitpos, size_t channel_n)
        .           {
        .           	size_t		byte;
        .           	size_t		offset;
        .           	uint8_t		value;
        .           	uint8_t		raw;
        .           
5,250,384 ( 0.13%)  	byte = bitpos >> 3;
        .           	offset = bitpos & 7;
1,040,400 ( 0.02%)  	value = context->current_line[byte];
        .           	raw = value;
        .           	if (context->bit_depths < 8)
        .           	{
        .           		raw = ((value >> (8 - context->bit_depths - offset))
        .           				& context->channel_max);
        .           		value = raw * 255 / context->channel_max;
        .           	}
   18,240 ( 0.00%)  	if (context->png->palette_size != 0)
        .           		value = raw;
        .           	if (channel_n == 0)
1,040,400 ( 0.02%)  		out->r = value;
        .           	else if (channel_n == 1)
2,080,800 ( 0.05%)  		out->g = value;
        .           	else if (channel_n == 2)
2,080,800 ( 0.05%)  		out->b = value;
        .           	else
   96,768 ( 0.00%)  		out->a = value;
        .           }
        .           
        .           static bool	unpack_clean(t_png_unfilter_context *context, t_png_pixel8 *out)
        .           {
        .           	t_png				*png;
        .           	t_png_color_type	type;
        .           
        .           	png = context->png;
        .           	type = png->header.color_type;
2,080,800 ( 0.05%)  	if (type == PNG_COLOR_GRAYSCALE)
        .           		*out = (t_png_pixel8){out->r, out->r, out->r, 255};
2,080,800 ( 0.05%)  	else if (type == PNG_COLOR_GRAYSCALE_ALPHA)
        .           		*out = (t_png_pixel8){out->r, out->r,
        .           			out->r, out->g};
2,080,800 ( 0.05%)  	else if (type == PNG_COLOR_PALETTE)
        .           	{
        .           		if (out->r >= png->palette_size)
        .           			return (false);
        .           		*out = png->palette[out->r];
        .           	}
2,080,800 ( 0.05%)  	else if (type == PNG_COLOR_RGB)
1,984,032 ( 0.05%)  		out->a = 255;
        .           	return (true);
        .           }

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
Ir                     
--------------------------------------------------------------------------------
3,758,842,481 (90.01%)  events annotated

